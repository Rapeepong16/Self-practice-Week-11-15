## Synchronous Programming
เป็นการ run ทำงานแบบต่อเนื่อง step1 --> step2 --> step3 (รอคำสั่งก่อนหน้าเเล้วค่อยคำสั่งต่อไป)

## Asynchronous
เมื่อสั่งให้ทำงานใดงานหนึ่งแล้ว โปรแกรมสามารถ ทำอย่างอื่นต่อไปได้โดยไม่ต้องรอให้ขั้นตอนก่อนหน้าจบก่อน

## Promise
ผลลัพธ์ของการทำงานแบบ asynchronous
- pending	กำลังดำเนินการอยู่ (ยังไม่เสร็จ)
- fulfilled	ทำงานเสร็จเรียบร้อย (สำเร็จ)
- rejected	ทำงานล้มเหลว (เกิดข้อผิดพลาด)

## REST API + Fetch + Error Handling
REST API ใช้ fetch() ใน JavaScript เพื่อทำ CRUD และเน้นเรื่องการจัดการ error ให้เป็นข้อความที่ user อ่านรู้เรื่อง ไม่ใช่ error แบบ technical ที่มาจาก backend  เช่น 404, 500  ซึ่งมักทำให้ผู้ใช้สับสน การแยกโค้ดออกเป็นสองส่วนช่วยให้ระบบเรียบร้อยขึ้น คือไฟล์สำหรับติดต่อ API โดยตรง และไฟล์สำหรับจัดการ logic 

error handling และ transaction design ที่ต้องคิดแบบ business logic ว่าเวลาเกิดปัญหาในแต่ละขั้น ใครควรรับผิดชอบ และควร handle หรือโยน error ต่อไป

เวลาเราเขียน library ที่แชร์ใช้หลายที่ ควรมี message แบบ general หรือ specific ซึ่งคำตอบคือ library ควรเป็น general message เพราะมันทำงานกับหลาย entity เช่น item, product, code หรืออะไรก็แล้วแต่ ถ้า library ผูกกับคำเฉพาะมากเกินไปมัน reuse ยาก

ยกตัวอย่างเช่นใน fetch-lib ถ้า getItem() error ข้อความไม่ควรเป็น “Error fetching product” แต่ควรเป็น “Fetching failed” แบบกลาง ๆ แล้วปล่อยให้ code management เป็นคนเปลี่ยน message ให้เฉพาะตาม entity ของมันเอง

## Flow

UI --> Code Management --> Fetch-lib --> Backend

fetch-lib ควร throw error เพราะไม่รู้ entity
management ควร handle หรือ throw ต่อ เพื่อปรับ message
UI ควร handle เสมอ เพราะเป็นที่แสดงผลให้ user

ถ้าเป็นขั้นสำคัญ เช่นการจ่ายเงิน ควรติดต่อ back-end ทุกครั้งเพื่อยืนยันข้อมูล
แต่ถ้าเป็นแค่การเพิ่ม item ใน cart อาจยังไม่ต้องรีเฟรช backend

